package com.discordbot.battle.integration;

import com.discordbot.battle.config.BattleProperties;
import com.discordbot.battle.entity.ActiveBattle;
import com.discordbot.battle.entity.PlayerCharacter;
import com.discordbot.battle.entity.PlayerCharacterTestFactory;
import com.discordbot.battle.repository.AbilityRepository;
import com.discordbot.battle.repository.BattleTurnRepository;
import com.discordbot.battle.repository.CharacterAbilityRepository;
import com.discordbot.battle.repository.PlayerCharacterRepository;
import com.discordbot.battle.service.*;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

/**
 * Automated User Testing: Cooldown and Rate Limit Exploit Tests
 * Phase 13: Test Suite Build-Out
 *
 * These tests verify that users cannot exploit battle system through:
 * - Rapid battle creation attempts
 * - Attempting to bypass cooldowns
 * - Trying to accept own challenges
 * - Multiple simultaneous challenge attempts
 */
class BattleCooldownExploitTest {

    @Mock
    private PlayerCharacterRepository characterRepository;

    @Mock
    private CharacterAbilityRepository characterAbilityRepository;

    @Mock
    private BattleTurnRepository turnRepository;

    @Mock
    private com.discordbot.battle.repository.BattleSessionRepository sessionRepository;

    @Mock
    private BattleMetricsService metricsService;

    @Mock
    private StatusEffectService statusEffectService;

    @Mock
    private SpellResourceService spellResourceService;

    @Mock
    private AbilityRepository abilityRepository;

    private BattleProperties battleProperties;
    private BattleService battleService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        battleProperties = new BattleProperties();
        battleProperties.setEnabled(true);

        battleService = new BattleService(
            characterRepository,
            characterAbilityRepository,
            turnRepository,
            battleProperties,
            spellResourceService,
            abilityRepository,
            statusEffectService,
            sessionRepository,
            metricsService,
            new SimpleMeterRegistry()
        );
    }

    /**
     * Automated User Testing: Rapid Challenge Creation
     * Tests that user cannot create multiple challenges rapidly (potential DoS attack).
     */
    @Test
    void exploitTest_rapidChallengeCreation_preventedByActiveBattleCheck() {
        // Given: Two users
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "500000000000000001", "999999999999999999", "Warrior", "Human",
            14, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "500000000000000002", "999999999999999999", "Rogue", "Elf",
            12, 16, 12, 10, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("500000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("500000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Alice creates first challenge
        ActiveBattle battle1 = battleService.createChallenge("999999999999999999", "500000000000000001", "500000000000000002");
        assertNotNull(battle1, "First challenge should succeed");

        // Then: Alice tries to create another challenge immediately (spam)
        // Should fail because Alice already has pending/active battle
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.createChallenge("999999999999999999", "500000000000000001", "500000000000000002");
        });

        assertTrue(
            exception.getMessage().contains("already in") || exception.getMessage().contains("active battle") || exception.getMessage().contains("pending"),
            "Should prevent rapid challenge creation with message: " + exception.getMessage()
        );
    }

    /**
     * Automated User Testing: Self-Accept Exploit
     * Tests that user cannot accept their own challenge.
     */
    @Test
    void exploitTest_cannotAcceptOwnChallenge() {
        // Given: Two users
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "600000000000000001", "999999999999999999", "Warrior", "Human",
            14, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "600000000000000002", "999999999999999999", "Rogue", "Elf",
            12, 16, 12, 10, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("600000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("600000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Alice challenges Bob
        ActiveBattle battle = battleService.createChallenge("999999999999999999", "600000000000000001", "600000000000000002");

        // Then: Alice tries to accept her own challenge
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.acceptChallenge(battle.getId(), "600000000000000001");
        });

        assertTrue(
            exception.getMessage().contains("Only the opponent") || exception.getMessage().contains("not the opponent"),
            "Should prevent self-accept with message: " + exception.getMessage()
        );
    }

    /**
     * Automated User Testing: Challenge Spam to Same Target
     * Tests that user cannot spam challenges to the same target while battle is pending.
     */
    @Test
    void exploitTest_cannotSpamChallengeToSameTarget() {
        // Given: Two users
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "700000000000000001", "999999999999999999", "Warrior", "Human",
            14, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "700000000000000002", "999999999999999999", "Rogue", "Elf",
            12, 16, 12, 10, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("700000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("700000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Alice challenges Bob
        ActiveBattle battle1 = battleService.createChallenge("999999999999999999", "700000000000000001", "700000000000000002");
        assertEquals(ActiveBattle.BattleStatus.PENDING, battle1.getStatus(), "First challenge should be pending");

        // Then: Alice tries to challenge Bob again while first challenge is pending
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.createChallenge("999999999999999999", "700000000000000001", "700000000000000002");
        });

        assertTrue(
            exception.getMessage().contains("already in") || exception.getMessage().contains("active battle") || exception.getMessage().contains("pending"),
            "Should prevent duplicate challenges with message: " + exception.getMessage()
        );
    }

    /**
     * Automated User Testing: Attack on Wrong Turn
     * Tests that users cannot perform actions out of turn (turn order exploit).
     */
    @Test
    void exploitTest_cannotAttackOnOpponentTurn() {
        // Given: Two users in active battle
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "800000000000000001", "999999999999999999", "Warrior", "Human",
            14, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "800000000000000002", "999999999999999999", "Rogue", "Elf",
            12, 16, 12, 10, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("800000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("800000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Battle starts
        ActiveBattle battle = battleService.createChallenge("999999999999999999", "800000000000000001", "800000000000000002");
        battle = battleService.acceptChallenge(battle.getId(), "800000000000000002");
        battle.setTestDiceSuppliers(() -> 12, () -> 4);

        String currentTurnUserId = battle.getCurrentTurnUserId();
        String notCurrentTurnUserId = currentTurnUserId.equals("800000000000000001") ? "800000000000000002" : "800000000000000001";

        // Then: User who is NOT on current turn tries to attack
        final String battleId = battle.getId();
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.performAttack(battleId, notCurrentTurnUserId);
        });

        assertTrue(
            exception.getMessage().contains("Not your turn"),
            "Should prevent out-of-turn actions with message: " + exception.getMessage()
        );
    }

    /**
     * Automated User Testing: Post-Battle Action Exploit
     * Tests that users cannot perform actions after battle has ended.
     */
    @Test
    void exploitTest_cannotPerformActionsAfterBattleEnds() {
        // Given: Two users in battle
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "900000000000000001", "999999999999999999", "Warrior", "Human",
            18, 12, 14, 10, 10, 10 // High STR for quick victory
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "900000000000000002", "999999999999999999", "Wizard", "Human",
            8, 8, 8, 16, 12, 10 // Low HP
        );

        when(characterRepository.findByUserIdAndGuildId("900000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("900000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Battle starts and completes
        ActiveBattle battle = battleService.createChallenge("999999999999999999", "900000000000000001", "900000000000000002");
        battle = battleService.acceptChallenge(battle.getId(), "900000000000000002");
        battle.setTestDiceSuppliers(() -> 18, () -> 6); // High rolls for quick end

        // Fight until battle ends
        while (battle.isActive()) {
            BattleService.AttackResult result = battleService.performAttack(
                battle.getId(),
                battle.getCurrentTurnUserId()
            );
            battle = result.battle();
        }

        assertTrue(battle.isEnded(), "Battle should have ended");
        String anyUserId = "900000000000000001";

        // Then: User tries to attack after battle ended
        final String battleId = battle.getId();
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.performAttack(battleId, anyUserId);
        });

        assertTrue(
            exception.getMessage().contains("not active") || exception.getMessage().contains("ended") || exception.getMessage().contains("Battle not active"),
            "Should prevent post-battle actions with message: " + exception.getMessage()
        );
    }

    /**
     * Automated User Testing: Challenge Decline and Re-challenge
     * Tests that after declining, the same challenge can be attempted again.
     */
    @Test
    void exploitTest_challengeDeclineAllowsNewChallenge() {
        // Given: Two users
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "110000000000000001", "999999999999999999", "Warrior", "Human",
            14, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "110000000000000002", "999999999999999999", "Rogue", "Elf",
            12, 16, 12, 10, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("110000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("110000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Alice challenges Bob
        ActiveBattle battle1 = battleService.createChallenge("999999999999999999", "110000000000000001", "110000000000000002");

        // Bob declines
        ActiveBattle declinedBattle = battleService.declineChallenge(battle1.getId(), "110000000000000002");
        assertEquals(ActiveBattle.BattleStatus.ENDED, declinedBattle.getStatus(), "Battle should be ended after decline");

        // Then: Alice can challenge Bob again (this is allowed after decline)
        ActiveBattle battle2 = battleService.createChallenge("999999999999999999", "110000000000000001", "110000000000000002");
        assertNotNull(battle2, "New challenge should be allowed after decline");
        assertEquals(ActiveBattle.BattleStatus.PENDING, battle2.getStatus(), "New challenge should be pending");
        assertNotEquals(battle1.getId(), battle2.getId(), "New challenge should have different ID");
    }

    /**
     * Automated User Testing: Forfeit After Loss Exploit
     * Tests that user cannot forfeit an already-ended battle to avoid ELO loss.
     */
    @Test
    void exploitTest_cannotForfeitAfterBattleEnds() {
        // Given: Two users in battle
        PlayerCharacter alice = PlayerCharacterTestFactory.create(
            "120000000000000001", "999999999999999999", "Warrior", "Human",
            18, 12, 14, 10, 10, 10
        );
        PlayerCharacter bob = PlayerCharacterTestFactory.create(
            "120000000000000002", "999999999999999999", "Wizard", "Human",
            8, 8, 8, 16, 12, 10
        );

        when(characterRepository.findByUserIdAndGuildId("120000000000000001", "999999999999999999"))
            .thenReturn(Optional.of(alice));
        when(characterRepository.findByUserIdAndGuildId("120000000000000002", "999999999999999999"))
            .thenReturn(Optional.of(bob));

        when(characterAbilityRepository.findByCharacter(any())).thenReturn(java.util.List.of());

        // When: Battle completes normally
        ActiveBattle battle = battleService.createChallenge("999999999999999999", "120000000000000001", "120000000000000002");
        battle = battleService.acceptChallenge(battle.getId(), "120000000000000002");
        battle.setTestDiceSuppliers(() -> 18, () -> 6);

        while (battle.isActive()) {
            BattleService.AttackResult result = battleService.performAttack(
                battle.getId(),
                battle.getCurrentTurnUserId()
            );
            battle = result.battle();
        }

        assertTrue(battle.isEnded(), "Battle should have ended normally");
        String loserId = battle.getWinnerUserId().equals("120000000000000001") ? "120000000000000002" : "120000000000000001";

        // Then: Loser tries to forfeit after losing (to avoid ELO penalty)
        final String battleId = battle.getId();
        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {
            battleService.forfeit(battleId, loserId);
        });

        assertTrue(
            exception.getMessage().contains("not active") || exception.getMessage().contains("ended") || exception.getMessage().contains("Battle not active"),
            "Should prevent forfeit after battle ends with message: " + exception.getMessage()
        );
    }
}
